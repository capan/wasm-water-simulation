(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[0],{

/***/ "../pkg/wasm_water_simulation.js":
/*!***************************************!*\
  !*** ../pkg/wasm_water_simulation.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("throw new Error(\"Module parse failed: Unexpected token (620:72)\\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\\n| \\n|     if (typeof module_or_path === 'undefined') {\\n>         module_or_path = new URL('wasm_water_simulation_bg.wasm', import.meta.url);\\n|     }\\n|     const imports = __wbg_get_imports();\");\n\n//# sourceURL=webpack:///../pkg/wasm_water_simulation.js?");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var wasm_water_simulation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! wasm-water-simulation */ \"../pkg/wasm_water_simulation.js\");\n/* harmony import */ var wasm_water_simulation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(wasm_water_simulation__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\nconst CELL_SIZE = 15; // px\nconst GRID_COLOR = \"#CCCCCC\";\nconst WATER_COLOR = \"#0339fc\";\n\n// Construct the universe, and get its width and height.\nwasm_water_simulation__WEBPACK_IMPORTED_MODULE_0__[\"Universe\"].new().then(async (universe) => {\n    // // Initialize the map\n    // const map = L.map('map').setView([51.505, -0.09], 13);\n\n    // // Add OpenStreetMap tile layer\n    // L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n    //     attribution: '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors',\n    //     maxZoom: 19,\n    // }).addTo(map);\n\n    const width = universe.width();\n    const height = universe.height();\n    // Give the canvas room for all of our cells and a 1px border\n    // around each of them.\n    const canvas = document.getElementById(\"wasm-water-simulation\");\n    canvas.height = (CELL_SIZE + 1) * height + 1;\n    canvas.width = (CELL_SIZE + 1) * width + 1;\n    const ctx = canvas.getContext('2d');\n    let animationId = null;\n    let msWaitTicks = 0;\n    let count = 0;\n    const playPauseButton = document.getElementById(\"play-pause\");\n    const stepButton = document.getElementById(\"step\");\n    const speedDisplay = document.getElementById('speed-display');\n    const tickRange = document.getElementById('tick-range');\n    tickRange.addEventListener('input', () => {\n        msWaitTicks = (100 - tickRange.value) * 10;\n        speedDisplay.textContent = `Render Speed: ${1000 / msWaitTicks} FPS`;\n    });\n    tickRange.value = 900; // Default value\n    tickRange.setAttribute('data-value', tickRange.value);\n    tickRange.addEventListener('input', () => {\n        tickRange.setAttribute('data-value', tickRange.value);\n        msWaitTicks = (100 - tickRange.value) * 10;\n        console.log(`Adjusted msWaitTicks to: ${msWaitTicks}`);\n    });\n\n    const iterationCount = document.getElementById(\"iteration\");\n    const heightInfo = document.getElementById('height');\n    const locationInfo = document.getElementById('row-col');\n\n    let lastRenderTime = 0;\n\n\n    const renderLoop = (timestamp) => {\n        if (!lastRenderTime || timestamp - lastRenderTime >= msWaitTicks) {\n            lastRenderTime = timestamp;\n            universe.tick();\n            drawCells();\n            iterationCount.textContent = `Current iteration: ${animationId}`;\n        }\n        animationId = requestAnimationFrame(renderLoop);\n    };\n\n    const isPaused = () => {\n        return animationId === null;\n    };\n    const play = () => {\n        playPauseButton.textContent = \"⏸\";\n        lastRenderTime = 0; // Reset to avoid unnecessary delay\n        animationId = requestAnimationFrame(renderLoop);\n    };\n\n    const pause = () => {\n        playPauseButton.textContent = \"▶\";\n        cancelAnimationFrame(animationId);\n        animationId = null;\n    };\n\n    playPauseButton.addEventListener(\"click\", event => {\n        if (isPaused()) {\n            play();\n        } else {\n            pause();\n        }\n    });\n\n    stepButton.addEventListener(\"click\", (event) => {\n        universe.tick();\n        drawCells();\n        animationId = requestAnimationFrame(renderLoop);\n        iterationCount.textContent = `Current iteration: ${animationId}`;\n        count = 0;\n    });\n\n\n    const drawGrid = () => {\n        ctx.beginPath();\n        ctx.strokeStyle = GRID_COLOR;\n\n        // Vertical lines.\n        for (let i = 0; i <= width; i++) {\n            ctx.moveTo(i * (CELL_SIZE + 1) + 1, 0);\n            ctx.lineTo(i * (CELL_SIZE + 1) + 1, (CELL_SIZE + 1) * height + 1);\n        }\n\n        // Horizontal lines.\n        for (let j = 0; j <= height; j++) {\n            ctx.moveTo(0, j * (CELL_SIZE + 1) + 1);\n            ctx.lineTo((CELL_SIZE + 1) * width + 1, j * (CELL_SIZE + 1) + 1);\n        }\n\n        ctx.stroke();\n    };\n\n    const getIndex = (row, column) => {\n        return row * width + column;\n    };\n\n    const drawCells = () => {\n        const maxHeight = universe.max_height();\n        const minHeight = universe.min_height();\n        const cellsPtr = universe.cells();\n        const cells = new Uint32Array(wasm_water_simulation__WEBPACK_IMPORTED_MODULE_0__[\"memory\"].buffer, cellsPtr, width * height);\n        const waterCellsPtr = universe.water_cell_locations();\n        const waterCellsCount = universe.water_cells_count();\n        const originalArray = new Uint32Array(wasm_water_simulation__WEBPACK_IMPORTED_MODULE_0__[\"memory\"].buffer, waterCellsPtr, waterCellsCount * 2);\n        const waterCells = Array.from(originalArray);\n        const waterCellsMap = {};\n        while (waterCells.length) {\n            const splicedArray = waterCells.splice(0, 2);\n            waterCellsMap[splicedArray.join(\"\")] = splicedArray;\n        };\n        ctx.beginPath();\n        for (let row = 0; row < height; row++) {\n            for (let col = 0; col < width; col++) {\n                const idx = getIndex(row, col);\n                let key = [row, col].join(\"\");\n                if (waterCellsMap[key]) {\n                    ctx.fillStyle = WATER_COLOR;\n                } else {\n                    const normalized = (cells[idx] - minHeight) * (255 - 0) / (maxHeight - minHeight)\n                    ctx.fillStyle = `rgb(\n                    ${normalized},\n                    ${normalized},\n                    ${normalized})`\n                }\n                ctx.fillRect(\n                    col * (CELL_SIZE + 1) + 1,\n                    row * (CELL_SIZE + 1) + 1,\n                    CELL_SIZE,\n                    CELL_SIZE\n                );\n            }\n        }\n\n        ctx.stroke();\n    };\n\n    canvas.addEventListener(\"mousemove\", event => {\n        const boundingRect = canvas.getBoundingClientRect();\n        const scaleX = canvas.width / boundingRect.width;\n        const scaleY = canvas.height / boundingRect.height;\n        const canvasLeft = (event.clientX - boundingRect.left) * scaleX;\n        const canvasTop = (event.clientY - boundingRect.top) * scaleY;\n        const row = Math.min(Math.floor(canvasTop / (CELL_SIZE + 1)), height - 1);\n        const col = Math.min(Math.floor(canvasLeft / (CELL_SIZE + 1)), width - 1);\n        heightInfo.textContent = `Height value: ${universe.get_cell_value(row, col)}`;\n        locationInfo.textContent = `Row-Col: ${row}-${col}`;\n        universe.handle_user_input(row, col);\n    })\n\n    drawGrid();\n    drawCells();\n    requestAnimationFrame(renderLoop);\n}).catch((err) => {\n    debugger\n    console.log(err)\n});\n\n\n\n\n\n\n//# sourceURL=webpack:///./index.js?");

/***/ })

}]);